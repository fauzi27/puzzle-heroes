<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Puzzle Heroes RPG: Enhanced</title>
    
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Verdana&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap');
        
        body { 
            font-family: 'Fredoka One', 'Verdana', sans-serif; 
            background-color: var(--tg-theme-bg-color, #0f172a); 
            color: var(--tg-theme-text-color, #ffffff);
            overflow: hidden; 
            touch-action: none; 
            user-select: none; 
            -webkit-user-select: none; 
        }
        .game-font { text-shadow: 2px 2px 0px #000; letter-spacing: 1px; }
        
        /* Animation Keyframes */
        @keyframes pulse-glow { 0%, 100% { filter: brightness(1) drop-shadow(0 0 0px transparent); transform: scale(1); } 50% { filter: brightness(1.5) drop-shadow(0 0 10px gold); transform: scale(1.1); } }
        @keyframes spin-fast { 0% { transform: rotate(0deg) scale(1); } 100% { transform: rotate(360deg) scale(1.1); } }
        @keyframes combo-pop { 0% { transform: scale(0) rotate(-10deg); opacity: 0; } 50% { transform: scale(1.5) rotate(5deg); opacity: 1; } 100% { transform: scale(1) rotate(0deg); opacity: 0; } }
        @keyframes screen-shake { 0%, 100% { transform: translate(0,0); } 25% { transform: translate(-5px, 5px); } 50% { transform: translate(5px, -5px); } 75% { transform: translate(-5px, -5px); } }

        /* Existing Animations */
        @keyframes sway-hero { 0%, 100% { transform: translateX(-3px); } 50% { transform: translateX(3px); } }
        @keyframes sway-enemy { 0%, 100% { transform: translateX(3px); } 50% { transform: translateX(-3px); } }
        @keyframes float { 0%, 100% { transform: translateY(0px); } 50% { transform: translateY(-6px); } }
        @keyframes breathe { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.02); } }
        @keyframes punch-pop { 0% { transform: scale(0) rotate(-45deg); opacity: 0; } 40% { transform: scale(1.5) rotate(0deg); opacity: 1; } 60% { transform: scale(1.2) rotate(10deg); } 100% { transform: scale(1.5) translateY(-20px); opacity: 0; } }
        @keyframes hit-shake { 0%, 100% { transform: translateX(0); } 20%, 60% { transform: translateX(-6px) rotate(-2deg); filter: brightness(2) sepia(1) hue-rotate(-50deg); } 40%, 80% { transform: translateX(6px) rotate(2deg); } }
        @keyframes particle-pop { 0% { transform: scale(0.5) translateY(0); opacity: 1; } 100% { transform: scale(0) translateY(-50px) rotate(180deg); opacity: 0; } }
        @keyframes float-up-fade { 0% { transform: translate(-50%, 0) scale(1); opacity: 1; } 100% { transform: translate(-50%, -80px) scale(1.2); opacity: 0; } }
        @keyframes crumble { 0% { transform: scale(1); opacity: 1; } 100% { transform: scale(0); opacity: 0; } }
        @keyframes drop-in { 0% { transform: translateY(-200%); } 100% { transform: translateY(0); } }

        .anim-fall { animation: drop-in 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); }
        .anim-special-bomb { animation: pulse-glow 1s infinite ease-in-out; z-index: 10; }
        .anim-special-nova { animation: spin-fast 2s linear infinite; z-index: 10; border-radius: 50%; box-shadow: 0 0 15px rgba(255,255,255,0.8); }
        .anim-shake-screen { animation: screen-shake 0.3s ease-in-out; }
        .anim-combo { animation: combo-pop 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
        
        .css-board-frame {
            background: linear-gradient(to bottom, #1e293b, #0f172a);
            border: 4px solid #475569;
            border-radius: 16px;
            box-shadow: 0 0 0 4px #0f172a, 0 10px 25px rgba(0,0,0,0.7);
        }
        
        .css-hp-bar {
            background: #0f172a; border: 2px solid #334155; border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5); position: relative; overflow: hidden;
        }

        .btn-game { border-bottom-width: 4px; transition: all 0.1s; }
        .btn-game:active { border-bottom-width: 0px; transform: translateY(4px); }

        .star-icon {
            display: inline-block; width: 16px; height: 16px;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23eab308'%3E%3Cpath d='M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z'/%3E%3C/svg%3E");
            background-size: cover;
        }
    </style>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
        import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js";
        import { getAuth, signInWithPopup, GoogleAuthProvider, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js";

        // FIREBASE CONFIG (Tetap sama)
        const firebaseConfig = {
            apiKey: "AIzaSyBXxNettfJao-Eb-Y_a1dNuZ8_DOiX_-fo",
            authDomain: "puzzle-heroes-d5df2.firebaseapp.com",
            projectId: "puzzle-heroes-d5df2",
            storageBucket: "puzzle-heroes-d5df2.firebasestorage.app",
            messagingSenderId: "63425481716",
            appId: "1:63425481716:web:e496e835b3d071235cc7a1",
            measurementId: "G-TCN0MV463X"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        const provider = new GoogleAuthProvider();

        window.loginGoogle = async () => {
            try { return (await signInWithPopup(auth, provider)).user; } catch (error) { alert("Error: " + error.message); return null; }
        };
        window.logoutGoogle = async () => { await signOut(auth); window.location.reload(); };
        window.authListener = (cb) => onAuthStateChanged(auth, cb);
        window.loadCloudData = async (uid) => {
            try { const s = await getDoc(doc(db, "players", uid.toString())); return s.exists() ? s.data() : null; } catch { return null; }
        };
        window.saveCloudData = async (uid, d) => {
            try { await setDoc(doc(db, "players", uid.toString()), d, { merge: true }); } catch (e) { console.error(e); }
        };
    </script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const ASSETS = {
          btn_play: "https://res.cloudinary.com/dsutaioqw/image/upload/v1770120268/btn_play_rcewal.png",
          bg_main: "https://res.cloudinary.com/dsutaioqw/image/upload/v1/puzzle%20hero/bg_main.png",
          hero: "https://res.cloudinary.com/dsutaioqw/image/upload/v1770120266/hero_knqmzd.png",
          enemy_goblin: "https://res.cloudinary.com/dsutaioqw/image/upload/v1770120266/monster_goblin_lcvfpv.png",
          enemy_boss: "https://res.cloudinary.com/dsutaioqw/image/upload/v1770120266/monster_bos_tn2b0a.png",
          gem_fire: "https://res.cloudinary.com/dsutaioqw/image/upload/v1770120267/gem-fire_rhcs6t.png", 
          gem_water: "https://res.cloudinary.com/dsutaioqw/image/upload/v1770120266/gem_water_yk5zsx.png",
          gem_nature: "https://res.cloudinary.com/dsutaioqw/image/upload/v1770120267/gem_nature_jj3l1g.png",
          gem_lightning: "https://res.cloudinary.com/dsutaioqw/image/upload/v1770120267/gem_lightning_lu9s2z.png",
          gem_shield: "https://res.cloudinary.com/dsutaioqw/image/upload/v1770120267/gem_shield_bdizjp.png",
        };

        const BOARD_ROWS = 7;
        const BOARD_COLS = 6;
        const GEM_TYPES = ['red', 'blue', 'green', 'yellow', 'purple'];
        const GEM_CONFIG = {
          red:    { assetKey: 'gem_fire',      effect: 'dmg', val: 1.0, color: '#ef4444' },
          blue:   { assetKey: 'gem_water',     effect: 'dmg', val: 1.0, color: '#3b82f6' },
          yellow: { assetKey: 'gem_lightning', effect: 'dmg', val: 1.5, color: '#eab308' },
          green:  { assetKey: 'gem_nature',    effect: 'heal', val: 1.5, color: '#22c55e' },
          purple: { assetKey: 'gem_shield',    effect: 'shd', val: 2.0, color: '#a855f7' },
        };
        
        const MONSTER_NAMES = ["Slime", "Goblin", "Wolf", "Orc", "Troll", "Golem", "Warlock", "Dragon", "Demon", "God"];
        const formatNumber = (num) => {
            if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
            if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
            return num.toString();
        };

        const SmartImage = ({ assetKey, className = "", style }) => {
            const [error, setError] = useState(false);
            return (
                <div className={`relative w-full h-full ${className}`} style={style}>
                    {!error ? <img src={ASSETS[assetKey]} className="w-full h-full object-contain" onError={() => setError(true)} /> 
                            : <div className="w-full h-full bg-slate-700/50 rounded-full animate-pulse"></div>}
                </div>
            );
        };

        // ============ LOGIC: MATCH & SPECIAL GEMS ============
        function checkMatches(boardToCheck) {
            const matched = new Set();
            const matchInfo = {};
            
            // Helper to add match
            const addMatch = (r, c, type, id, length, direction) => {
                matched.add(`${r},${c}`);
                if (!matchInfo[`${r},${c}`]) matchInfo[`${r},${c}`] = { type, id, length, direction };
                else if (length > matchInfo[`${r},${c}`].length) matchInfo[`${r},${c}`] = { type, id, length, direction };
            };

            // Horizontal
            for (let r = 0; r < BOARD_ROWS; r++) {
                for (let c = 0; c < BOARD_COLS; c++) {
                    const gem = boardToCheck[r][c];
                    if (!gem) continue;
                    let len = 1;
                    while (c + len < BOARD_COLS && boardToCheck[r][c + len]?.type === gem.type) len++;
                    if (len >= 3) {
                        const matchId = `h-${r}-${c}-${Date.now()}`;
                        for (let i = 0; i < len; i++) addMatch(r, c+i, gem.type, matchId, len, 'h');
                    }
                    c += len - 1; // Skip checked
                }
            }
            
            // Vertical
            for (let c = 0; c < BOARD_COLS; c++) {
                for (let r = 0; r < BOARD_ROWS; r++) {
                    const gem = boardToCheck[r][c];
                    if (!gem) continue;
                    let len = 1;
                    while (r + len < BOARD_ROWS && boardToCheck[r + len][c]?.type === gem.type) len++;
                    if (len >= 3) {
                        const matchId = `v-${r}-${c}-${Date.now()}`;
                        for (let i = 0; i < len; i++) addMatch(r+i, c, gem.type, matchId, len, 'v');
                    }
                    r += len - 1;
                }
            }
            
            return Array.from(matched).map(str => {
                const [r, c] = str.split(',').map(Number);
                return { r, c, ...matchInfo[str] };
            });
        }

        // ============ MAIN GAME ============
        function GameApp() {
            const tg = window.Telegram.WebApp;
            const [user, setUser] = useState(null); 
            const activeUserId = user ? user.uid : (localStorage.getItem('guest_player_id') || 'guest');
            const activeUserName = user ? user.displayName : (localStorage.getItem('guest_player_name') || "Hero");

            // Game State
            const [gameState, setGameState] = useState('START'); // START, BATTLE, SHOP, REWARD, GAMEOVER
            const [level, setLevel] = useState(1);
            const [totalCoins, setTotalCoins] = useState(100); 
            const [stats, setStats] = useState({ hp: 0, atk: 0 }); 
            const [inventory, setInventory] = useState({ potion: 1, bomb: 0, shuffle: 1 });
            
            // Battle State
            const [hero, setHero] = useState({ maxHp: 100, hp: 100, atk: 15, shield: 0 });
            const [enemy, setEnemy] = useState({ name: 'Goblin', maxHp: 100, hp: 100, atk: 10, isBoss: false });
            const [board, setBoard] = useState([]);
            const [turn, setTurn] = useState('player'); 
            const [isProcessing, setIsProcessing] = useState(false);
            const [combo, setCombo] = useState(0);
            
            // VFX State
            const [particles, setParticles] = useState([]);
            const [floatTexts, setFloatTexts] = useState([]);
            const [screenShake, setScreenShake] = useState(false);
            const [dragStart, setDragStart] = useState(null);
            const [crushCells, setCrushCells] = useState([]);
            const [animState, setAnimState] = useState({ hero: '', enemy: '' });

            // Initialize
            useEffect(() => {
                if(!localStorage.getItem('guest_player_id')) localStorage.setItem('guest_player_id', 'g-'+Date.now());
                tg.ready(); tg.expand();
                window.authListener(u => {
                    setUser(u);
                    if(u) window.loadCloudData(u.uid).then(d => { if(d) { setLevel(d.level); setTotalCoins(d.totalCoins); setStats(d.bonusStats); setInventory(d.inventory); }});
                });
                setBoard(createBoard());
            }, []);

            // Save Progress
            useEffect(() => {
                if(gameState !== 'BATTLE' && activeUserId !== 'guest') {
                    window.saveCloudData(activeUserId, { level, totalCoins, bonusStats: stats, inventory, username: activeUserName });
                }
            }, [level, totalCoins, stats, inventory, gameState]);

            // Helper: Create Gem
            const createGem = (forceType) => ({
                id: Math.random().toString(36).substr(2, 9),
                type: forceType || GEM_TYPES[Math.floor(Math.random() * GEM_TYPES.length)],
                special: null // 'bomb', 'nova'
            });

            // Helper: Create Valid Board (No Matches)
            const createBoard = () => {
                let b;
                do {
                    b = Array(BOARD_ROWS).fill(null).map(() => Array(BOARD_COLS).fill(null).map(() => createGem()));
                } while (checkMatches(b).length > 0);
                return b;
            };

            // Helper: Calculate Stats
            const getHeroStats = () => {
                const baseHp = Math.floor(100 * Math.pow(1.08, level - 1)) + stats.hp;
                const baseAtk = Math.floor(15 * Math.pow(1.08, level - 1)) + stats.atk;
                return { maxHp: baseHp, hp: baseHp, atk: baseAtk, shield: 0 };
            };

            const getEnemyStats = () => {
                const isBoss = level % 5 === 0;
                const multiplier = Math.pow(1.1, level);
                return {
                    name: isBoss ? `BOSS ${MONSTER_NAMES[Math.min(Math.floor(level/5), MONSTER_NAMES.length-1)]}` : MONSTER_NAMES[Math.floor(Math.random()*MONSTER_NAMES.length)],
                    maxHp: Math.floor(100 * multiplier * (isBoss ? 3 : 1)),
                    hp: Math.floor(100 * multiplier * (isBoss ? 3 : 1)),
                    atk: Math.floor(8 * multiplier * (isBoss ? 1.5 : 1)),
                    isBoss
                };
            };

            // Start Battle
            const startLevel = () => {
                setHero(getHeroStats());
                setEnemy(getEnemyStats());
                setBoard(createBoard());
                setTurn('player');
                setIsProcessing(false);
                setCombo(0);
                setGameState('BATTLE');
            };

            // Actions
            const spawnVFX = (r, c, type, txt) => {
                const id = Date.now() + Math.random();
                if(txt) setFloatTexts(p => [...p, { id, r, c, txt, color: type === 'dmg' ? '#ef4444' : (type === 'heal' ? '#22c55e' : '#fff') }]);
                else setParticles(p => [...p, { id, top: r*14.28+7+'%', left: c*16.66+8+'%', color: GEM_CONFIG[type]?.color || '#fff' }]);
                setTimeout(() => {
                    if(txt) setFloatTexts(p => p.filter(x => x.id !== id));
                    else setParticles(p => p.filter(x => x.id !== id));
                }, 800);
            };

            const triggerShake = () => { setScreenShake(true); setTimeout(() => setScreenShake(false), 300); tg.HapticFeedback.impactOccurred('heavy'); };

            // ============ CORE MECHANIC: RESOLVE BOARD ============
            const resolveBoard = async (currentBoard, currentCombo = 0) => {
                setIsProcessing(true);
                let activeBoard = currentBoard.map(row => row.map(cell => ({...cell})));
                let hasMatches = true;
                let loopCount = 0;
                let comboCount = currentCombo;

                while (hasMatches && loopCount < 10) {
                    const matches = checkMatches(activeBoard);
                    if (matches.length === 0) { hasMatches = false; break; }

                    comboCount++;
                    if(comboCount > 1) setCombo(comboCount);

                    // 1. Process Logic (Damage, Special Creation)
                    const uniqueMatches = {}; // Store match info by ID to detect match-4/5
                    matches.forEach(m => {
                        if(!uniqueMatches[m.id]) uniqueMatches[m.id] = [];
                        uniqueMatches[m.id].push(m);
                    });

                    let dmgTotal = 0, healTotal = 0, shieldTotal = 0;
                    const specialSpawns = []; // {r, c, type}

                    // Process each distinct match group
                    Object.values(uniqueMatches).forEach(group => {
                        const first = group[0];
                        const length = group.length;
                        const gType = activeBoard[first.r][first.c].type;
                        
                        // Check for existing specials being detonated
                        group.forEach(m => {
                            const cell = activeBoard[m.r][m.c];
                            if(cell.special === 'bomb') {
                                // Explosion Logic
                                for(let rr = m.r-1; rr<=m.r+1; rr++) {
                                    for(let cc = m.c-1; cc<=m.c+1; cc++) {
                                        if(activeBoard[rr]?.[cc] && !matches.find(x => x.r===rr && x.c===cc)) {
                                            matches.push({r:rr, c:cc}); // Add to clear list
                                            spawnVFX(rr, cc, 'red', 'BOOM!');
                                        }
                                    }
                                }
                                triggerShake();
                            } else if(cell.special === 'nova') {
                                // Color Clear Logic
                                for(let rr=0; rr<BOARD_ROWS; rr++) {
                                    for(let cc=0; cc<BOARD_COLS; cc++) {
                                        if(activeBoard[rr][cc]?.type === gType) matches.push({r:rr, c:cc});
                                    }
                                }
                                triggerShake();
                            }
                        });

                        // Create New Specials
                        if (length >= 5) specialSpawns.push({ r: first.r, c: first.c, type: gType, special: 'nova' });
                        else if (length === 4) specialSpawns.push({ r: first.r, c: first.c, type: gType, special: 'bomb' });

                        // Stats Calculation
                        const mult = 1 + (comboCount * 0.2) + (length > 3 ? 0.5 : 0);
                        const conf = GEM_CONFIG[gType];
                        if (conf.effect === 'dmg') dmgTotal += hero.atk * conf.val * mult;
                        if (conf.effect === 'heal') healTotal += (hero.maxHp * 0.05) * mult;
                        if (conf.effect === 'shd') shieldTotal += 5 * mult;
                    });

                    // Apply Stats
                    if (dmgTotal > 0) {
                        setEnemy(prev => ({...prev, hp: Math.max(0, prev.hp - Math.floor(dmgTotal))}));
                        setAnimState(p => ({...p, enemy: 'anim-hit'})); spawnVFX(0,0,'dmg', `-${Math.floor(dmgTotal)}`);
                    }
                    if (healTotal > 0) {
                        setHero(prev => ({...prev, hp: Math.min(prev.maxHp, prev.hp + Math.floor(healTotal))}));
                        spawnVFX(0,0,'heal', `+${Math.floor(healTotal)}`);
                    }
                    if (shieldTotal > 0) setHero(prev => ({...prev, shield: prev.shield + Math.floor(shieldTotal)}));

                    // 2. Visual Crush
                    setCrushCells(matches.map(m => `${m.r},${m.c}`));
                    matches.forEach(m => spawnVFX(m.r, m.c, activeBoard[m.r][m.c].type));
                    await new Promise(r => setTimeout(r, 400));

                    // 3. Remove Gems
                    matches.forEach(m => activeBoard[m.r][m.c] = null);
                    
                    // 4. Spawn Specials
                    specialSpawns.forEach(s => {
                        activeBoard[s.r][s.c] = { ...createGem(s.type), special: s.special };
                    });

                    setBoard(activeBoard.map(r => [...r]));
                    setCrushCells([]);
                    setAnimState({hero:'', enemy:''});

                    // 5. Gravity
                    await new Promise(r => setTimeout(r, 100));
                    for(let c=0; c<BOARD_COLS; c++) {
                        let empty = 0;
                        for(let r=BOARD_ROWS-1; r>=0; r--) {
                            if(!activeBoard[r][c]) empty++;
                            else if(empty > 0) {
                                activeBoard[r+empty][c] = activeBoard[r][c];
                                activeBoard[r][c] = null;
                            }
                        }
                        for(let i=0; i<empty; i++) activeBoard[i][c] = createGem();
                    }
                    setBoard(activeBoard.map(r => [...r]));
                    
                    // Wait for fall
                    await new Promise(r => setTimeout(r, 400));
                    loopCount++;
                }

                setIsProcessing(false);
                setCombo(0);
                
                // End Turn Check
                if (enemy.hp <= 0) { // WIN
                     // Keep logic handled in useEffect
                } else {
                    setTurn('enemy');
                }
            };

            // Enemy Turn Logic
            useEffect(() => {
                if(turn === 'enemy' && enemy.hp > 0 && gameState === 'BATTLE' && !isProcessing) {
                    const doEnemyTurn = async () => {
                        setIsProcessing(true);
                        // Phase 1: Charge
                        setAnimState(p => ({...p, enemy: 'scale-110 brightness-125 duration-1000'}));
                        await new Promise(r => setTimeout(r, 1000));
                        
                        // Phase 2: Attack
                        setAnimState(p => ({...p, enemy: 'anim-sway-enemy'})); // Reset
                        triggerShake();
                        
                        // Calc Dmg
                        const rawDmg = Math.max(5, enemy.atk);
                        let finalDmg = rawDmg;
                        let shieldLeft = hero.shield;
                        if(shieldLeft > 0) {
                             if(shieldLeft >= finalDmg) { shieldLeft -= finalDmg; finalDmg = 0; spawnVFX(0,0,'shd', "BLOCKED"); }
                             else { finalDmg -= shieldLeft; shieldLeft = 0; }
                        }
                        
                        setHero(h => ({...h, hp: Math.max(0, h.hp - finalDmg), shield: shieldLeft}));
                        if(finalDmg > 0) {
                            spawnVFX(0,0,'dmg', `-${finalDmg}`);
                            setAnimState(p => ({...p, hero: 'anim-hit'}));
                        }

                        await new Promise(r => setTimeout(r, 800));
                        setAnimState({hero:'', enemy:''});
                        setTurn('player');
                        setIsProcessing(false);
                    };
                    doEnemyTurn();
                }
            }, [turn, gameState, isProcessing]);

            // Win/Loss Checks
            useEffect(() => {
                if(enemy.hp <= 0 && gameState === 'BATTLE') {
                    setTotalCoins(c => c + Math.floor(20 * Math.pow(1.1, level)));
                    setTimeout(() => setGameState('REWARD'), 1000);
                }
                if(hero.hp <= 0 && gameState === 'BATTLE') {
                    setTimeout(() => setGameState('GAMEOVER'), 1000);
                }
            }, [enemy.hp, hero.hp, gameState]);


            // Input Handling
            const handleTouchStart = (e, r, c) => {
                if(isProcessing || turn !== 'player') return;
                const touch = e.touches ? e.touches[0] : e;
                setDragStart({ r, c, x: touch.clientX, y: touch.clientY });
            };

            const handleTouchEnd = (e) => {
                if(!dragStart || isProcessing) return;
                const touch = e.changedTouches ? e.changedTouches[0] : e;
                const dx = touch.clientX - dragStart.x;
                const dy = touch.clientY - dragStart.y;
                
                if(Math.abs(dx) > 30 || Math.abs(dy) > 30) {
                    const r2 = Math.abs(dy) > Math.abs(dx) ? (dy > 0 ? dragStart.r + 1 : dragStart.r - 1) : dragStart.r;
                    const c2 = Math.abs(dx) > Math.abs(dy) ? (dx > 0 ? dragStart.c + 1 : dragStart.c - 1) : dragStart.c;
                    
                    if(r2 >= 0 && r2 < BOARD_ROWS && c2 >= 0 && c2 < BOARD_COLS) {
                        // Swap
                        const newBoard = board.map(row => row.map(cell => ({...cell})));
                        [newBoard[dragStart.r][dragStart.c], newBoard[r2][c2]] = [newBoard[r2][c2], newBoard[dragStart.r][dragStart.c]];
                        
                        if(checkMatches(newBoard).length > 0) {
                            setBoard(newBoard);
                            resolveBoard(newBoard);
                        } else {
                            // Invalid move visual feedback
                            tg.HapticFeedback.notificationOccurred('error');
                        }
                    }
                }
                setDragStart(null);
            };

            return (
                <div className={`h-screen w-full flex flex-col relative overflow-hidden bg-slate-900 ${screenShake ? 'anim-shake-screen' : ''}`}
                     onTouchEnd={handleTouchEnd} onMouseUp={handleTouchEnd}>
                    
                    {/* Background */}
                    <img src={ASSETS.bg_main} className="absolute inset-0 w-full h-full object-cover opacity-30" />
                    
                    {/* Header */}
                    <div className="relative z-10 p-2 flex justify-between items-start">
                        <div className="bg-slate-800/80 px-3 py-1 rounded-full border border-yellow-600 flex items-center gap-2">
                            <span>üí∞</span><span className="text-yellow-400 font-bold">{formatNumber(totalCoins)}</span>
                        </div>
                        <div className="text-center">
                            <div className="text-xs text-slate-400 uppercase tracking-widest font-bold">LEVEL {level}</div>
                            {turn === 'enemy' && <div className="text-red-500 font-black animate-pulse">ENEMY TURN</div>}
                        </div>
                        <button onClick={() => gameState === 'BATTLE' ? setGameState('SHOP') : {}} className="text-xs bg-blue-600 px-2 py-1 rounded shadow">SHOP</button>
                    </div>

                    {/* Battle Area */}
                    <div className="flex-1 flex flex-col relative z-10">
                        {/* Enemy */}
                        <div className="flex-1 flex flex-col items-center justify-center relative">
                            <div className={`w-32 h-32 transition-all ${animState.enemy}`}>
                                <SmartImage assetKey={enemy.isBoss ? 'enemy_boss' : 'enemy_goblin'} className="drop-shadow-2xl" />
                            </div>
                            <div className="w-48 h-4 css-hp-bar mt-2">
                                <div className="h-full bg-red-600 transition-all duration-300" style={{width: `${(enemy.hp/enemy.maxHp)*100}%`}}></div>
                                <div className="absolute inset-0 text-[10px] flex items-center justify-center font-bold text-white drop-shadow">{enemy.name} {formatNumber(enemy.hp)}</div>
                            </div>
                            
                            {/* Damage/Heal Text */}
                            {floatTexts.map(ft => (
                                <div key={ft.id} className="absolute text-4xl font-black game-font" 
                                     style={{top: '50%', left: '50%', color: ft.color, animation: 'float-up-fade 0.8s forwards'}}>
                                    {ft.txt}
                                </div>
                            ))}
                        </div>

                        {/* Combo Counter */}
                        {combo > 1 && (
                            <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 z-50 text-5xl font-black text-yellow-400 game-font anim-combo pointer-events-none drop-shadow-xl" style={{ textShadow: '4px 4px 0 #000' }}>
                                COMBO x{combo}!
                            </div>
                        )}

                        {/* Board */}
                        <div className="w-full max-w-[380px] mx-auto p-2 aspect-[6/7]">
                            <div className="css-board-frame w-full h-full p-2 grid grid-cols-6 grid-rows-7 gap-1 relative">
                                {board.map((row, r) => row.map((gem, c) => (
                                    <div key={`${r}-${c}`}
                                         onMouseDown={(e) => handleTouchStart(e, r, c)}
                                         onTouchStart={(e) => handleTouchStart(e, r, c)}
                                         className={`relative flex items-center justify-center transition-transform active:scale-90 ${crushCells.includes(`${r},${c}`) ? 'anim-crumble' : ''} ${gem?.id ? 'anim-fall' : ''}`}
                                    >
                                        {gem && (
                                            <>
                                                <SmartImage assetKey={GEM_CONFIG[gem.type].assetKey} className="drop-shadow-md z-10" />
                                                {/* Special Visuals */}
                                                {gem.special === 'bomb' && <div className="absolute inset-0 bg-red-500/30 rounded-full anim-special-bomb border-2 border-red-400"></div>}
                                                {gem.special === 'nova' && <div className="absolute -inset-1 border-4 border-dotted border-white rounded-full anim-special-nova"></div>}
                                            </>
                                        )}
                                    </div>
                                )))}
                                {/* Particles */}
                                {particles.map(p => (
                                    <div key={p.id} className="absolute w-4 h-4 rounded-full pointer-events-none z-20" 
                                         style={{backgroundColor: p.color, top: p.top, left: p.left, animation: 'particle-pop 0.6s ease-out forwards'}}></div>
                                ))}
                            </div>
                        </div>

                        {/* Hero */}
                        <div className="h-32 flex items-end justify-between px-4 pb-4 relative">
                            <div className="relative w-24">
                                <div className={`w-24 h-24 ${animState.hero}`}>
                                    <SmartImage assetKey="hero" className="scale-125 origin-bottom drop-shadow-xl" />
                                </div>
                                <div className="w-24 h-3 css-hp-bar absolute -bottom-2 left-0">
                                    <div className="h-full bg-green-500 transition-all" style={{width: `${(hero.hp/hero.maxHp)*100}%`}}></div>
                                    <div className="absolute inset-0 text-[8px] flex items-center justify-center font-bold text-white">{hero.hp}/{hero.maxHp}</div>
                                </div>
                                {hero.shield > 0 && <div className="absolute -top-2 left-0 bg-purple-600 text-[10px] px-1 rounded border border-white font-bold">üõ°Ô∏è {hero.shield}</div>}
                            </div>
                            
                            {/* Inventory */}
                            <div className="flex gap-2 mb-2">
                                {Object.entries(inventory).map(([key, val]) => (
                                    <button key={key} onClick={() => {
                                        if(turn!=='player' || val <= 0) return;
                                        setInventory(p => ({...p, [key]: p[key]-1}));
                                        // Simple item logic implementation
                                        if(key==='potion') { setHero(h=>({...h, hp: Math.min(h.maxHp, h.hp + h.maxHp*0.4)})); spawnVFX(0,0,'heal','HEAL'); }
                                        if(key==='bomb') { setEnemy(e=>({...e, hp: Math.max(0, e.hp - hero.atk*3)})); spawnVFX(0,0,'dmg',`-${hero.atk*3}`); triggerShake(); }
                                        if(key==='shuffle') setBoard(createBoard());
                                    }} className={`w-10 h-10 rounded-full border-2 border-slate-600 bg-slate-800 flex items-center justify-center relative active:scale-90 transition-transform ${val===0 ? 'opacity-50 grayscale':''}`}>
                                        <span className="text-xl">{key==='potion'?'üß™':(key==='bomb'?'üí£':'üîÑ')}</span>
                                        <span className="absolute -top-1 -right-1 bg-red-600 text-[9px] w-4 h-4 rounded-full flex items-center justify-center border border-slate-900">{val}</span>
                                    </button>
                                ))}
                            </div>
                        </div>
                    </div>

                    {/* MENUS (Overlays) */}
                    
                    {gameState === 'START' && (
                        <div className="absolute inset-0 z-50 bg-slate-900/95 flex flex-col items-center justify-center gap-6 animate-in fade-in zoom-in duration-300">
                            <h1 className="text-5xl font-black text-yellow-500 game-font text-center leading-tight drop-shadow-xl">PUZZLE<br/><span className="text-white">HEROES</span><br/><span className="text-2xl text-blue-400">RPG</span></h1>
                            <button onClick={startLevel} className="w-64 py-4 bg-green-600 rounded-xl border-b-4 border-green-800 text-2xl font-black text-white active:border-b-0 active:translate-y-1 shadow-lg transition-all hover:brightness-110">PLAY START</button>
                            <div className="text-white/50 text-sm font-mono mt-4">v2.0 Enhanced Edition</div>
                        </div>
                    )}

                    {gameState === 'REWARD' && (
                        <div className="absolute inset-0 z-50 bg-black/90 flex flex-col items-center justify-center gap-4 text-center p-6">
                            <div className="text-6xl mb-2">üèÜ</div>
                            <h2 className="text-4xl font-black text-green-400 game-font">VICTORY!</h2>
                            <p className="text-white text-lg">Coins Earned: <span className="text-yellow-400 font-bold">+{Math.floor(20 * Math.pow(1.1, level))}</span></p>
                            <button onClick={() => { setLevel(l => l+1); startLevel(); }} className="mt-4 px-8 py-3 bg-yellow-500 text-yellow-900 font-black text-xl rounded-lg border-b-4 border-yellow-700 active:scale-95">NEXT STAGE ‚ñ∂</button>
                            <button onClick={() => setGameState('SHOP')} className="text-white/70 underline text-sm">Go to Shop</button>
                        </div>
                    )}

                    {gameState === 'GAMEOVER' && (
                        <div className="absolute inset-0 z-50 bg-red-900/90 flex flex-col items-center justify-center gap-4 text-center p-6">
                            <h2 className="text-5xl font-black text-white game-font">DEFEAT</h2>
                            <p className="text-white/80">The monsters got you...</p>
                            <button onClick={() => { setLevel(1); startLevel(); }} className="mt-4 px-8 py-3 bg-white text-red-900 font-black text-xl rounded-lg border-b-4 border-slate-300 active:scale-95">TRY AGAIN</button>
                        </div>
                    )}

                    {gameState === 'SHOP' && (
                        <div className="absolute inset-0 z-50 bg-slate-800 flex flex-col">
                            <div className="p-4 bg-slate-900 flex justify-between items-center shadow-lg">
                                <h2 className="text-2xl font-black text-yellow-400">SHOP</h2>
                                <button onClick={() => setGameState('BATTLE')} className="bg-slate-700 px-3 py-1 rounded text-white font-bold">CLOSE</button>
                            </div>
                            <div className="p-4 space-y-4 overflow-y-auto">
                                <div className="bg-slate-700 p-4 rounded-xl flex justify-between items-center border border-white/10">
                                    <div><div className="font-bold text-white text-lg">‚öîÔ∏è Upgrade ATK</div><div className="text-xs text-slate-400">Current: {stats.atk}</div></div>
                                    <button onClick={() => { if(totalCoins >= 100) { setTotalCoins(c=>c-100); setStats(s=>({...s, atk:s.atk+2})); }}} className="bg-blue-600 px-4 py-2 rounded-lg font-bold text-white border-b-4 border-blue-800 active:border-b-0">100üí∞</button>
                                </div>
                                <div className="bg-slate-700 p-4 rounded-xl flex justify-between items-center border border-white/10">
                                    <div><div className="font-bold text-white text-lg">‚ù§Ô∏è Upgrade HP</div><div className="text-xs text-slate-400">Current: {stats.hp}</div></div>
                                    <button onClick={() => { if(totalCoins >= 100) { setTotalCoins(c=>c-100); setStats(s=>({...s, hp:s.hp+10})); }}} className="bg-blue-600 px-4 py-2 rounded-lg font-bold text-white border-b-4 border-blue-800 active:border-b-0">100üí∞</button>
                                </div>
                            </div>
                        </div>
                    )}

                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<GameApp />);
    </script>
</body>
</html>
