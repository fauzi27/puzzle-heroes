<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Puzzle Heroes RPG - Improved</title>
    
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Verdana&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap');
        
        body { 
            font-family: 'Fredoka One', 'Verdana', sans-serif; 
            background-color: var(--tg-theme-bg-color, #0f172a); 
            color: var(--tg-theme-text-color, #ffffff);
            overflow: hidden; 
            touch-action: none; 
            user-select: none; 
        }
        .game-font { text-shadow: 2px 2px 0px #000; letter-spacing: 1px; }
        
        /* ANIMASI */
        @keyframes sway-hero { 0%, 100% { transform: translateX(-3px); } 50% { transform: translateX(3px); } }
        @keyframes sway-enemy { 0%, 100% { transform: translateX(3px); } 50% { transform: translateX(-3px); } }
        @keyframes float { 0%, 100% { transform: translateY(0px); } 50% { transform: translateY(-6px); } }
        @keyframes breathe { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.02); } }
        @keyframes punch-pop { 0% { transform: scale(0) rotate(-45deg); opacity: 0; } 40% { transform: scale(1.5) rotate(0deg); opacity: 1; } 60% { transform: scale(1.2) rotate(10deg); } 100% { transform: scale(1.5) translateY(-20px); opacity: 0; } }
        @keyframes hit-shake { 0%, 100% { transform: translateX(0); } 20%, 60% { transform: translateX(-6px) rotate(-2deg); filter: brightness(2) sepia(1) hue-rotate(-50deg); } 40%, 80% { transform: translateX(6px) rotate(2deg); } }
        @keyframes particle-pop { 0% { transform: scale(0.5) translateY(0); opacity: 1; } 100% { transform: scale(1.5) translateY(-30px); opacity: 0; } }
        @keyframes float-up-fade { 0% { transform: translate(-50%, 0) scale(1); opacity: 1; } 80% { opacity: 1; } 100% { transform: translate(-50%, -60px) scale(1.2); opacity: 0; } }
        @keyframes crumble { 0% { transform: scale(1) translateY(0) rotate(0deg); opacity: 1; filter: brightness(1.5); } 100% { transform: scale(0.2) translateY(20px) rotate(45deg); opacity: 0; } }
        @keyframes bomb-flash { 0% { background-color: rgba(255,255,255,0); } 50% { background-color: rgba(255,255,255,0.8); } 100% { background-color: rgba(255,255,255,0); } }
        @keyframes drop-in { 0% { transform: translateY(-100%); opacity: 0; } 60% { transform: translateY(5%); opacity: 1; } 100% { transform: translateY(0); opacity: 1; } }
        @keyframes pulse-match { 0% { transform: scale(1); } 50% { transform: scale(1.15); } 100% { transform: scale(1); } }
        @keyframes chain-combo { 0% { opacity: 0; transform: scale(0.5); } 50% { opacity: 1; transform: scale(1.2); } 100% { opacity: 0; transform: scale(1); } }

        .anim-fall { animation: drop-in 0.4s cubic-bezier(0.25, 1, 0.5, 1) backwards; }
        .anim-pop-in { animation: breathe 0.3s ease-out forwards; }
        .anim-float { animation: float 4s ease-in-out infinite; }
        .anim-breathe { animation: breathe 3s ease-in-out infinite; }
        .anim-sway-hero { animation: sway-hero 2s ease-in-out infinite; }
        .anim-sway-enemy { animation: sway-enemy 2s ease-in-out infinite; }
        .anim-punch { animation: punch-pop 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; z-index: 100; pointer-events: none; }
        .anim-hit { animation: hit-shake 0.4s ease-in-out; }
        .anim-particle { animation: particle-pop 0.6s ease-out forwards; pointer-events: none; }
        .anim-crumble { animation: crumble 0.4s ease-in forwards; pointer-events: none; }
        .anim-bomb { animation: bomb-flash 0.5s ease-out; }
        .anim-pulse { animation: pulse-match 0.4s ease-out; }
        .anim-chain { animation: chain-combo 0.6s ease-out; }
        
        .css-board-frame {
            background: rgba(15, 23, 42, 0.8);
            border: 8px solid #334155;
            border-radius: 12px;
            box-shadow: 0 0 0 2px #1e293b, inset 0 0 20px rgba(0,0,0,0.8), 0 10px 20px rgba(0,0,0,0.5);
        }
        
        .css-hp-bar {
            background: #1e293b; 
            border: 3px solid #475569; 
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.5);
            position: relative; 
            overflow: hidden;
        }

        .btn-game {
            border-bottom-width: 2px; 
            transition: all 0.1s;
        }
        .btn-game:active {
            border-bottom-width: 0px;
            transform: translateY(2px) scale(0.95);
        }

        .star-icon {
            display: inline-block;
            width: 20px;
            height: 20px;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23eab308'%3E%3Cpath d='M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: center;
        }

        img { -webkit-user-drag: none; user-select: none; pointer-events: none; }
        
        /* COMBO INDICATOR */
        .combo-badge {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #ff006e, #fb5607, #ffbe0b);
            padding: 12px 24px;
            border-radius: 50px;
            color: white;
            font-weight: 900;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 200;
            border: 3px solid white;
            box-shadow: 0 0 20px rgba(255, 0, 110, 0.8);
        }
    </style>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
        import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js";
        import { getAuth, signInWithPopup, GoogleAuthProvider, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js";

        const firebaseConfig = {
            apiKey: "AIzaSyBXxNettfJao-Eb-Y_a1dNuZ8_DOiX_-fo",
            authDomain: "puzzle-heroes-d5df2.firebaseapp.com",
            projectId: "puzzle-heroes-d5df2",
            storageBucket: "puzzle-heroes-d5df2.firebasestorage.app",
            messagingSenderId: "63425481716",
            appId: "1:63425481716:web:e496e835b3d071235cc7a1",
            measurementId: "G-TCN0MV463X"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        const provider = new GoogleAuthProvider();

        window.loginGoogle = async () => {
            try {
                const result = await signInWithPopup(auth, provider);
                return result.user;
            } catch (error) {
                alert("Login Error: " + error.message);
                return null;
            }
        };

        window.logoutGoogle = async () => {
            try {
                await signOut(auth);
                window.location.reload();
            } catch (error) { console.error(error); }
        };

        window.authListener = (callback) => {
            onAuthStateChanged(auth, (user) => {
                if (user) callback(user);
                else callback(null);
            });
        };

        window.loadCloudData = async (userId) => {
            if (!userId) return null;
            try {
                const docRef = doc(db, "players", userId.toString());
                const docSnap = await getDoc(docRef);
                return docSnap.exists() ? docSnap.data() : null;
            } catch (error) { return null; }
        };

        window.saveCloudData = async (userId, data) => {
            if (!userId) return;
            try {
                await setDoc(doc(db, "players", userId.toString()), data, { merge: true });
            } catch (error) { console.error("Save Error", error); }
        };
    </script>

</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // ============ ASSETS ============
        const ASSETS = {
          btn_play: "https://res.cloudinary.com/dsutaioqw/image/upload/v1770120268/btn_play_rcewal.png",
          bg_main: "https://res.cloudinary.com/dsutaioqw/image/upload/v1/puzzle%20hero/bg_main.png",
          hero: "https://res.cloudinary.com/dsutaioqw/image/upload/v1770120266/hero_knqmzd.png",
          enemy_goblin: "https://res.cloudinary.com/dsutaioqw/image/upload/v1770120266/monster_goblin_lcvfpv.png",
          enemy_boss: "https://res.cloudinary.com/dsutaioqw/image/upload/v1770120266/monster_bos_tn2b0a.png",
          gem_fire: "https://res.cloudinary.com/dsutaioqw/image/upload/v1770120267/gem-fire_rhcs6t.png", 
          gem_water: "https://res.cloudinary.com/dsutaioqw/image/upload/v1770120266/gem_water_yk5zsx.png",
          gem_nature: "https://res.cloudinary.com/dsutaioqw/image/upload/v1770120267/gem_nature_jj3l1g.png",
          gem_lightning: "https://res.cloudinary.com/dsutaioqw/image/upload/v1770120267/gem_lightning_lu9s2z.png",
          gem_shield: "https://res.cloudinary.com/dsutaioqw/image/upload/v1770120267/gem_shield_bdizjp.png",
        };

        const BOARD_ROWS = 7;
        const BOARD_COLS = 6;
        const GEM_TYPES = ['red', 'blue', 'green', 'yellow', 'purple'];
        
        // ============ GEM CONFIG DENGAN MULTIPLIER ============
        const GEM_CONFIG = {
          red:    { assetKey: 'gem_fire',      effect: 'dmg', val: 1.0 },
          blue:   { assetKey: 'gem_water',     effect: 'dmg', val: 1.0 },
          yellow: { assetKey: 'gem_lightning', effect: 'dmg', val: 1.5 },
          green:  { assetKey: 'gem_nature',    effect: 'heal', val: 1.5 },
          purple: { assetKey: 'gem_shield',    effect: 'shd', val: 2.0 },
        };
        
        const MONSTER_NAMES = ["Slime", "Goblin", "Wolf", "Orc", "Troll", "Golem", "Warlock", "Dragon", "Demon", "God"];
        const formatNumber = (num) => {
            if (num >= 1000000000) return (num / 1000000000).toFixed(2) + 'B';
            if (num >= 1000000) return (num / 1000000).toFixed(2) + 'M';
            if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
            return num.toString();
        };

        const SmartImage = ({ assetKey, className = "", style, srcOverride }) => {
            const [error, setError] = useState(false);
            const src = srcOverride || ASSETS[assetKey];
            useEffect(() => { setError(false); }, [src]);
            return (
                <div className={`relative w-full h-full overflow-hidden ${className}`} style={style}>
                    {(error || !src) && <div className="absolute inset-0 bg-slate-800/50 rounded-lg flex items-center justify-center text-xs text-white/30">IMG</div>}
                    {!error && src && <img src={src} className="w-full h-full object-contain" onError={() => setError(true)} />}
                </div>
            );
        };

        // ============ IMPROVED MATCH DETECTION ============
        /**
         * Enhanced checkMatches dengan support untuk:
         * - Match-3, Match-4, Match-5+
         * - Horizontal & Vertical matches
         * - 2x2 Square detection
         * - Combo multiplier tracking
         */
        function checkMatches(boardToCheck) {
            const matched = new Set();
            const matchInfo = {}; // Track match size untuk combo bonus
            
            // --- HORIZONTAL MATCHES ---
            for (let r = 0; r < BOARD_ROWS; r++) {
                for (let c = 0; c < BOARD_COLS; c++) {
                    const type = boardToCheck[r][c];
                    if (!type) continue;
                    
                    // Count consecutive gems ke kanan
                    let matchLength = 1;
                    while (c + matchLength < BOARD_COLS && boardToCheck[r][c + matchLength] === type) {
                        matchLength++;
                    }
                    
                    // Jika match >= 3, tambahkan ke set
                    if (matchLength >= 3) {
                        for (let i = 0; i < matchLength; i++) {
                            const key = `${r},${c + i}`;
                            matched.add(key);
                            matchInfo[key] = { size: matchLength, direction: 'h' };
                        }
                    }
                }
            }
            
            // --- VERTICAL MATCHES ---
            for (let c = 0; c < BOARD_COLS; c++) {
                for (let r = 0; r < BOARD_ROWS; r++) {
                    const type = boardToCheck[r][c];
                    if (!type) continue;
                    
                    // Count consecutive gems ke bawah
                    let matchLength = 1;
                    while (r + matchLength < BOARD_ROWS && boardToCheck[r + matchLength][c] === type) {
                        matchLength++;
                    }
                    
                    // Jika match >= 3, tambahkan ke set
                    if (matchLength >= 3) {
                        for (let i = 0; i < matchLength; i++) {
                            const key = `${r + i},${c}`;
                            matched.add(key);
                            matchInfo[key] = { size: matchLength, direction: 'v' };
                        }
                    }
                }
            }
            
            // --- 2x2 SQUARE DETECTION (BONUS FEATURE) ---
            // Hanya deteksi jika belum match dari horizontal/vertical
            for (let r = 0; r < BOARD_ROWS - 1; r++) {
                for (let c = 0; c < BOARD_COLS - 1; c++) {
                    const type = boardToCheck[r][c];
                    if (type && 
                        boardToCheck[r][c+1] === type && 
                        boardToCheck[r+1][c] === type && 
                        boardToCheck[r+1][c+1] === type) {
                        
                        // Mark semua 4 gem
                        [`${r},${c}`, `${r},${c+1}`, `${r+1},${c}`, `${r+1},${c+1}`].forEach(key => {
                            matched.add(key);
                            matchInfo[key] = { size: 4, special: 'square' };
                        });
                    }
                }
            }
            
            // Convert ke array dengan match info
            const result = Array.from(matched).map(str => { 
                const [r, c] = str.split(',').map(Number);
                return { r, c, ...matchInfo[str] };
            });
            
            return result;
        }

        /**
         * Kalkulasi damage/effect dengan multiplier untuk match size
         * Match-3 = 1.0x
         * Match-4 = 1.5x
         * Match-5+ = 2.0x
         * Special Square = 2.5x
         */
        function calculateMatchMultiplier(matches) {
            // Find largest match group
            let maxSize = 0;
            let hasSquare = false;
            
            matches.forEach(m => {
                if (m.special === 'square') hasSquare = true;
                if (m.size) maxSize = Math.max(maxSize, m.size);
            });
            
            if (hasSquare) return 2.5;
            if (maxSize >= 5) return 2.0;
            if (maxSize === 4) return 1.5;
            return 1.0;
        }

        // ============ MAIN GAME COMPONENT ============
        function GameApp() {
            const tg = window.Telegram.WebApp;

            // --- STATE UNTUK COMBO SYSTEM ---
            const [comboCount, setComboCount] = useState(0);
            const [comboDisplay, setComboDisplay] = useState(null);

            // --- 1. IDENTITAS & AUTHENTICATION ---
            const [user, setUser] = useState(null); 
            const [isTelegram, setIsTelegram] = useState(!!tg.initDataUnsafe?.user);
            
            const getBrowserId = () => {
                let savedId = localStorage.getItem('guest_player_id');
                if (!savedId) {
                    savedId = 'guest_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
                    localStorage.setItem('guest_player_id', savedId);
                }
                return savedId;
            };

            const activeUserId = isTelegram 
                ? tg.initDataUnsafe.user.id 
                : (user ? user.uid : getBrowserId());

            const activeUserName = isTelegram 
                ? tg.initDataUnsafe.user.first_name 
                : (user ? user.displayName : (localStorage.getItem('guest_player_name') || "Guest Player"));

            // --- 2. STATE GAME UTAMA ---
            const defaultStats = {
                level: 1,
                totalCoins: 100,
                bonusStats: { hp: 0, atk: 0 },
                inventory: { potion: 1, bomb: 0, shuffle: 1 }
            };

            const [gameState, setGameState] = useState('START'); 
            const [level, setLevel] = useState(defaultStats.level);
            const [totalCoins, setTotalCoins] = useState(defaultStats.totalCoins); 
            const [bonusStats, setBonusStats] = useState(defaultStats.bonusStats); 
            const [inventory, setInventory] = useState(defaultStats.inventory);
            const [isCloudLoaded, setIsCloudLoaded] = useState(false);

            const [showIAP, setShowIAP] = useState(false); 
            const [showProfileModal, setShowProfileModal] = useState(false);
            const [isFalling, setIsFalling] = useState(false);

            // --- 3. LOGIKA AUTH & LOAD DATA ---
            useEffect(() => {
                if (!isTelegram && window.authListener) {
                    window.authListener((googleUser) => {
                        if (googleUser) {
                            setUser(googleUser);
                            localStorage.setItem('guest_player_name', googleUser.displayName);
                            if(window.loadCloudData) {
                                window.loadCloudData(googleUser.uid).then(data => {
                                    if(data) {
                                        if(data.level) setLevel(data.level);
                                        if(data.totalCoins) setTotalCoins(data.totalCoins);
                                        if(data.bonusStats) setBonusStats(data.bonusStats);
                                        if(data.inventory) setInventory(data.inventory);
                                    }
                                });
                            }
                        } else {
                            setUser(null);
                        }
                    });
                }
            }, [isTelegram]);

            useEffect(() => {
                tg.ready();
                tg.expand();
                tg.BackButton.onClick(() => { setGameState('BATTLE'); tg.BackButton.hide(); });
            }, []);

            useEffect(() => {
                const initGameData = async () => {
                    if (window.loadCloudData) {
                        const cloudData = await window.loadCloudData(activeUserId);
                        if (cloudData) {
                            if(cloudData.level) setLevel(cloudData.level);
                            if(cloudData.totalCoins) setTotalCoins(cloudData.totalCoins);
                            if(cloudData.bonusStats) setBonusStats(cloudData.bonusStats);
                            if(cloudData.inventory) setInventory(cloudData.inventory);
                        }
                    }
                    setIsCloudLoaded(true);
                };
                initGameData();
            }, [activeUserId]);

            useEffect(() => {
                if (!isCloudLoaded) return;
                const dataToSave = {
                    level, totalCoins, bonusStats, inventory,
                    lastUpdated: Date.now(),
                    username: activeUserName
                };
                const saveTimeout = setTimeout(() => {
                    if (window.saveCloudData) window.saveCloudData(activeUserId, dataToSave);
                }, 2000);
                return () => clearTimeout(saveTimeout);
            }, [level, totalCoins, bonusStats, inventory, isCloudLoaded, activeUserId, activeUserName]);


            // --- 4. GAMEPLAY LOGIC (BATTLE) ---
            const [currentReward, setCurrentReward] = useState(0);
            
            const calculateHeroStats = (lvl, bonuses) => {
                const baseHp = Math.floor(100 * Math.pow(1.07, lvl - 1));
                const baseAtk = Math.floor(15 * Math.pow(1.07, lvl - 1));
                return { maxHp: baseHp + bonuses.hp, hp: baseHp + bonuses.hp, atk: baseAtk + bonuses.atk, shield: 0, def: 0 };
            };

            const [hero, setHero] = useState(calculateHeroStats(level, bonusStats));
            const [enemy, setEnemy] = useState({ name: 'Loading', hp: 100, maxHp: 100, atk: 10 });
            
            const [board, setBoard] = useState([]);
            const [turn, setTurn] = useState('player'); 
            const [turnBanner, setTurnBanner] = useState(''); 
            const [isProcessing, setIsProcessing] = useState(false);
            
            // Visuals
            const [heroAnim, setHeroAnim] = useState('');
            const [enemyAnim, setEnemyAnim] = useState('');
            const [punchEffect, setPunchEffect] = useState(null); 
            const [particles, setParticles] = useState([]);
            const [floatingText, setFloatingText] = useState([]);
            const [dragState, setDragState] = useState(null); 
            const [crushingCells, setCrushingCells] = useState([]); 
            const [screenFlash, setScreenFlash] = useState('');

            const generateEnemy = (lvl) => {
                const isBoss = lvl % 5 === 0;
                const idx = Math.min(Math.floor((lvl - 1) / 5), MONSTER_NAMES.length - 1);
                return {
                    name: isBoss ? `BOSS ${MONSTER_NAMES[idx]}` : MONSTER_NAMES[idx],
                    maxHp: Math.floor(100 * Math.pow(1.08, lvl) * (isBoss ? 2.5 : 1)),
                    hp: Math.floor(100 * Math.pow(1.08, lvl) * (isBoss ? 2.5 : 1)),
                    atk: Math.floor(10 * Math.pow(1.08, lvl) * (isBoss ? 1.5 : 1)),
                    isBoss
                };
            };

            useEffect(() => {
                if (isCloudLoaded) {
                    setHero(prev => {
                        const newStats = calculateHeroStats(level, bonusStats);
                        return { ...newStats, hp: newStats.maxHp };
                    });
                    setEnemy(generateEnemy(level));
                }
            }, [isCloudLoaded, level, bonusStats]);

            useEffect(() => { setBoard(createValidBoard()); }, []);

            useEffect(() => {
                if (gameState === 'SHOP' || showIAP) tg.BackButton.show(); else tg.BackButton.hide();
            }, [gameState, showIAP]);

            const calculateCoinReward = (lvl) => Math.floor(15 * Math.pow(1.085, lvl - 1));
            const getUpgradePrice = (type) => type === 'atk' ? Math.floor(hero.atk * 25) : (type === 'hp' ? Math.floor(hero.maxHp * 1.5) : 999999);

            function createValidBoard() {
                let newBoard, isValid = false;
                while (!isValid) {
                    newBoard = [];
                    for (let r = 0; r < BOARD_ROWS; r++) {
                        const row = [];
                        for (let c = 0; c < BOARD_COLS; c++) row.push(GEM_TYPES[Math.floor(Math.random() * GEM_TYPES.length)]);
                        newBoard.push(row);
                    }
                    if (checkMatches(newBoard).length === 0) isValid = true;
                }
                return newBoard;
            }

            const spawnParticles = (r, c, type) => {
                const newPart = { id: Date.now() + Math.random(), top: `${(r*100/BOARD_ROWS)+7}%`, left: `${(c*100/BOARD_COLS)+8}%`, type };
                setParticles(p => [...p, newPart]);
                setTimeout(() => setParticles(p => p.filter(x => x.id !== newPart.id)), 600);
            };

            const triggerPunch = (target) => { setPunchEffect(target); setTimeout(() => setPunchEffect(null), 600); };
            const spawnText = (txt, color) => {
                 const id = Date.now() + Math.random();
                 setFloatingText(p => [...p, { id, txt, color }]);
                 setTimeout(() => setFloatingText(prev => prev.filter(item => item.id !== id)), 2000); 
            };

            const handleStarsPurchase = (coins, stars) => {
                if (!tg.initDataUnsafe?.user) {
                    alert("[MODE BROWSER] Simulasi: Koin bertambah " + coins);
                    setTotalCoins(prev => prev + coins);
                    return;
                }
                const invoiceLink = "https://t.me/$D8iuOsDkIFQgBAAAUoNG2nbqTHI"; 
                if (!invoiceLink || invoiceLink.includes("PASTE_LINK")) { tg.showAlert("‚ö†Ô∏è Developer lupa pasang Link Invoice!"); return; }
                tg.openInvoice(invoiceLink, (status) => {
                    if (status === 'paid') {
                        tg.MainButton.showProgress();
                        setTimeout(() => {
                            tg.MainButton.hideProgress();
                            setTotalCoins(prev => prev + coins);
                            if(window.saveCloudData) {
                                window.saveCloudData(activeUserId, { totalCoins: totalCoins + coins, lastUpdated: Date.now() });
                            }
                            tg.showAlert(`‚úÖ PEMBAYARAN SUKSES!\n+${formatNumber(coins)} Koin Diterima.`);
                            setShowIAP(false); 
                        }, 1000);
                    } else if (status === 'failed') { tg.showAlert("Pembayaran Gagal."); }
                });
            };

            const useItem = (type) => {
                if (isProcessing || turn !== 'player' || inventory[type] <= 0) return;
                setInventory(prev => ({...prev, [type]: prev[type] - 1}));

                if (type === 'potion') {
                    const healAmount = Math.floor(hero.maxHp * 0.3);
                    setHero(prev => ({...prev, hp: Math.min(prev.maxHp, prev.hp + healAmount)}));
                    spawnText(`+${healAmount}`, '#22c55e');
                    spawnText("POTION!", '#fff');
                } else if (type === 'shuffle') {
                    setIsProcessing(true);
                    spawnText("SHUFFLE!", '#3b82f6');
                    setTimeout(() => { setBoard(createValidBoard()); setIsProcessing(false); }, 500);
                } else if (type === 'bomb') {
                    setIsProcessing(true);
                    spawnText("BOOM!", '#f97316');
                    setScreenFlash('anim-bomb');
                    setTimeout(() => setScreenFlash(''), 500);
                    const centerR = 3, centerC = 3;
                    const targets = [];
                    for(let r = centerR-1; r <= centerR+1; r++) { for(let c = centerC-1; c <= centerC+1; c++) { if (board[r] && board[r][c]) targets.push({r, c}); } }
                    const dmg = Math.floor(hero.atk * 2.0); 
                    setEnemy(prev => ({...prev, hp: Math.max(0, prev.hp - dmg)}));
                    spawnText(`-${dmg}`, '#ef4444');
                    triggerPunch('enemy');
                    const newBoard = board.map(row => [...row]);
                    setCrushingCells(targets.map(m => `${m.r},${m.c}`));
                    targets.forEach(t => { if (newBoard[t.r][t.c]) { spawnParticles(t.r, t.c, newBoard[t.r][t.c]); newBoard[t.r][t.c] = null; } });
                    setBoard(newBoard);
                    setTimeout(async () => {
                         setCrushingCells([]);
                         let activeBoard = newBoard.map(row => [...row]);
                         for(let c=0; c<BOARD_COLS; c++) {
                             let empty = 0;
                             for(let r=BOARD_ROWS-1; r>=0; r--) {
                                 if(activeBoard[r][c] === null) empty++;
                                 else if(empty > 0) { activeBoard[r+empty][c] = activeBoard[r][c]; activeBoard[r][c] = null; }
                             }
                             for(let i=0; i<empty; i++) activeBoard[i][c] = GEM_TYPES[Math.floor(Math.random() * GEM_TYPES.length)];
                         }
                         setBoard(activeBoard);
                         if (checkMatches(activeBoard).length > 0) setTimeout(() => resolveBoardWithCombo(activeBoard, 1), 300);
                         else setIsProcessing(false);
                    }, 600);
                }
            };

            const buyItem = (item, price) => {
                if (totalCoins >= price) {
                    setTotalCoins(prev => prev - price);
                    if (item === 'atk') setBonusStats(prev => ({ ...prev, atk: prev.atk + 2 })); 
                    else if (item === 'hp') setBonusStats(prev => ({ ...prev, hp: prev.hp + 10 })); 
                    else setInventory(prev => ({...prev, [item]: prev[item] + 1}));
                    tg.HapticFeedback.impactOccurred('medium');
                } else tg.HapticFeedback.notificationOccurred('error');
            };

            // ============ IMPROVED RESOLVE BOARD DENGAN COMBO SYSTEM ============
            const resolveBoardWithCombo = async (currentBoard, comboLevel = 1) => {
                let activeBoard = currentBoard.map(row => [...row]); 
                const matches = checkMatches(activeBoard);

                if (matches.length > 0) {
                    let totalDmg = 0, totalHeal = 0, totalShield = 0;
                    const multiplier = calculateMatchMultiplier(matches);
                    
                    // Display combo
                    if (comboLevel > 1) {
                        setComboDisplay({ level: comboLevel, multiplier });
                        setTimeout(() => setComboDisplay(null), 1000);
                    }

                    setCrushingCells(matches.map(m => `${m.r},${m.c}`));
                    matches.forEach(m => {
                        const type = activeBoard[m.r][m.c];
                        if (type) {
                            spawnParticles(m.r, m.c, type);
                            const conf = GEM_CONFIG[type];
                            if (conf.effect === 'dmg') totalDmg += hero.atk * conf.val * multiplier;
                            if (conf.effect === 'heal') totalHeal += (hero.maxHp * 0.05) * conf.val * multiplier; 
                            if (conf.effect === 'shd') totalShield += 10 * conf.val * multiplier; 
                        }
                    });

                    if (totalDmg > 0) { 
                        const finalDmg = Math.floor(totalDmg);
                        setEnemy(prev => ({...prev, hp: Math.max(0, prev.hp - finalDmg)})); 
                        triggerPunch('enemy'); 
                        setEnemyAnim('anim-hit'); 
                        setTimeout(() => setEnemyAnim(''), 300); 
                        spawnText(`-${finalDmg}`, '#ef4444'); 
                        tg.HapticFeedback.impactOccurred('light'); 
                    }
                    if (totalHeal > 0) { 
                        const finalHeal = Math.floor(totalHeal);
                        setHero(prev => ({...prev, hp: Math.min(prev.maxHp, prev.hp + finalHeal)})); 
                        spawnText(`+${finalHeal}`, '#22c55e'); 
                    }
                    if (totalShield > 0) { 
                        const finalShield = Math.floor(totalShield);
                        setHero(prev => ({...prev, shield: prev.shield + finalShield})); 
                        spawnText(`+${finalShield}`, '#a855f7'); 
                    }

                    await new Promise(r => setTimeout(r, 400));
                    setCrushingCells([]); 
                    matches.forEach(m => activeBoard[m.r][m.c] = null);
                    setBoard(activeBoard.map(row => [...row])); 
                    
                    await new Promise(r => setTimeout(r, 100));

                    // --- GRAVITY & SPAWN BARU ---
                    for(let c=0; c<BOARD_COLS; c++) {
                         let empty = 0;
                         for(let r=BOARD_ROWS-1; r>=0; r--) {
                             if(activeBoard[r][c] === null) empty++;
                             else if(empty > 0) { activeBoard[r+empty][c] = activeBoard[r][c]; activeBoard[r][c] = null; }
                         }
                         for(let i=0; i<empty; i++) activeBoard[i][c] = GEM_TYPES[Math.floor(Math.random() * GEM_TYPES.length)];
                    }

                    setIsFalling(true); 
                    setBoard(activeBoard.map(row => [...row])); 
                    setTimeout(() => setIsFalling(false), 450);
                    
                    await new Promise(r => setTimeout(r, 550)); // Tunggu gravity + cascade delay

                    // --- CHECK UNTUK CHAIN REACTION ---
                    const nextMatches = checkMatches(activeBoard);
                    if (nextMatches.length > 0) {
                        // COMBO!
                        setComboCount(comboLevel + 1);
                        await resolveBoardWithCombo(activeBoard, comboLevel + 1);
                    } else {
                        // Cascade selesai
                        setComboCount(0);
                        setIsProcessing(false);
                        setTurn('enemy'); 
                        setTurnBanner("GILIRAN MUSUH");
                        setTimeout(() => setTurnBanner(''), 1500);
                    }
                } else {
                    // Tidak ada match
                    setIsProcessing(false);
                    setTurn('enemy'); 
                    setTurnBanner("GILIRAN MUSUH");
                    setTimeout(() => setTurnBanner(''), 1500);
                }
            };

            useEffect(() => {
                if (turn === 'enemy' && enemy.hp > 0 && gameState === 'BATTLE' && !isProcessing) {
                    const enemyAct = async () => {
                        setIsProcessing(true);
                        await new Promise(r => setTimeout(r, 1500));
                        const r = Math.floor(Math.random() * (BOARD_ROWS-1)), c = Math.floor(Math.random() * (BOARD_COLS-1));
                        const newBoard = [...board];
                        [newBoard[r][c], newBoard[r][c+1]] = [newBoard[r][c+1], newBoard[r][c]];
                        setBoard(newBoard);
                        
                        const rawDmg = Math.max(5, enemy.atk - hero.def);
                        let finalDmg = rawDmg, shieldLeft = hero.shield;
                        if (shieldLeft > 0) {
                            if (shieldLeft >= finalDmg) { shieldLeft -= finalDmg; finalDmg = 0; spawnText("BLOCKED", "#a855f7"); }
                            else { finalDmg -= shieldLeft; shieldLeft = 0; }
                        }
                        setHero(h => ({...h, hp: Math.max(0, h.hp - finalDmg), shield: shieldLeft}));
                        if(finalDmg > 0) { triggerPunch('hero'); setHeroAnim('anim-hit'); spawnText(`-${finalDmg}`, '#ef4444'); tg.HapticFeedback.notificationOccurred('warning'); }
                        await new Promise(r => setTimeout(r, 1000));
                        setHeroAnim(''); setTurn('player'); setTurnBanner('GILIRAN KAMU'); setTimeout(() => setTurnBanner(''), 1500); setIsProcessing(false);
                    }
                    enemyAct();
                }
            }, [turn, gameState, isProcessing]);

            const handleDragStart = (e, r, c) => {
                if (isProcessing || turn !== 'player') return;
                const cx = e.touches ? e.touches[0].clientX : e.clientX, cy = e.touches ? e.touches[0].clientY : e.clientY;
                setDragState({ r, c, x: cx, y: cy });
            };

            const handleDragEnd = (e) => {
                if (!dragState) return;
                const cx = e.changedTouches ? e.changedTouches[0].clientX : e.clientX, cy = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
                const dx = cx - dragState.x, dy = cy - dragState.y;
                if (Math.abs(dx) > 30 || Math.abs(dy) > 30) {
                     const targetR = Math.abs(dy) > Math.abs(dx) ? (dy > 0 ? dragState.r + 1 : dragState.r - 1) : dragState.r;
                     const targetC = Math.abs(dx) > Math.abs(dy) ? (dx > 0 ? dragState.c + 1 : dragState.c - 1) : dragState.c;
                     if (targetR >= 0 && targetR < BOARD_ROWS && targetC >= 0 && targetC < BOARD_COLS) {
                         const tempBoard = board.map(row => [...row]);
                         [tempBoard[dragState.r][dragState.c], tempBoard[targetR][targetC]] = [tempBoard[targetR][targetC], tempBoard[dragState.r][dragState.c]];
                         if (checkMatches(tempBoard).length > 0) { 
                             setIsProcessing(true); 
                             setBoard(tempBoard); 
                             setTimeout(() => { resolveBoardWithCombo(tempBoard, 1); }, 200); 
                         } 
                     }
                }
                setDragState(null);
            };
            
            useEffect(() => {
                if (enemy.hp <= 0 && gameState === 'BATTLE') { 
                    const reward = calculateCoinReward(level); 
                    setCurrentReward(reward); 
                    setTimeout(() => { setGameState('REWARD'); tg.HapticFeedback.notificationOccurred('success'); }, 1000); 
                }
                if (hero.hp <= 0 && gameState === 'BATTLE') setGameState('GAMEOVER');
            }, [enemy.hp, hero.hp]);

            const handleNextLevel = () => {
                setTotalCoins(prev => prev + currentReward);
                setLevel(prev => prev + 1);
                setComboCount(0);
                setGameState('BATTLE'); setTurnBanner('START!'); setTimeout(()=>setTurnBanner(''), 1500); setTurn('player'); setIsProcessing(false);
            };

            const restartGame = () => {
                setLevel(1);
                setInventory({potion:1, bomb:0, shuffle:1}); 
                setComboCount(0);
                setGameState('BATTLE');
            };

            const handleProfile = () => {
                const isRunningInTelegram = (tg.platform && tg.platform !== 'unknown');
                if (isRunningInTelegram) {
                    if (isTelegram) {
                         tg.showAlert(`Akun Telegram: ${activeUserName}`);
                    } else if (user) {
                        tg.showConfirm(`Login: ${user.displayName}\nEmail: ${user.email}\n\nLogout?`, (ok) => {
                            if(ok) window.logoutGoogle();
                        });
                    } else {
                        tg.showPopup({
                            title: 'GUEST PLAYER',
                            message: 'Pilih opsi akun:',
                            buttons: [
                                {id: 'login', type: 'default', text: 'üåê Login Google'},
                                {id: 'rename', type: 'default', text: '‚úèÔ∏è Ganti Nama'},
                                {id: 'cancel', type: 'destructive', text: 'Tutup'}
                            ]
                        }, (btnId) => {
                            if(btnId === 'login') window.loginGoogle();
                            else if(btnId === 'rename') {
                                setTimeout(() => {
                                    const newName = prompt("Nama Baru:", activeUserName);
                                    if(newName) { localStorage.setItem('guest_player_name', newName); window.location.reload(); }
                                }, 300);
                            }
                        });
                    }
                    return; 
                }
                setShowProfileModal(true);
            };

            return (
                <div className="flex flex-col h-screen w-full select-none relative overflow-hidden"
                     onTouchStart={(e) => {}} 
                     onMouseUp={handleDragEnd} onTouchEnd={handleDragEnd}>
                     
                    {/* BACKGROUND */}
                    <div className={`absolute inset-0 z-50 pointer-events-none ${screenFlash}`}></div>
                    <div className="absolute inset-0 z-0 bg-slate-900">
                        <img src={ASSETS.bg_main} className="w-full h-full object-cover opacity-40" onError={(e) => e.target.style.display='none'}/>
                        <div className="absolute inset-0 bg-gradient-to-t from-slate-900 via-slate-900/50 to-slate-900/90"></div>
                    </div>

                    {/* COMBO INDICATOR */}
                    {comboDisplay && (
                        <div className="combo-badge anim-chain">
                            {comboDisplay.level}x COMBO<br/>
                            <span className="text-sm">√ó{comboDisplay.multiplier.toFixed(1)} DMG</span>
                        </div>
                    )}

                    {turnBanner && <div className="absolute top-40 w-full text-center z-50 text-4xl font-black text-white animate-pulse game-font drop-shadow-lg">{turnBanner}</div>}
                    
                    {/* HEADER */}
                    <div className="absolute top-0 w-full z-40 p-2 flex justify-between items-start">
                        <div className="flex items-center gap-2 bg-slate-900/80 border-2 border-yellow-600 rounded-full px-4 py-1 shadow-lg cursor-pointer active:scale-95 transition-transform"
                             onClick={() => { if(gameState==='BATTLE' || gameState==='REWARD' || gameState==='START') setGameState('SHOP'); }}>
                            <span className="text-2xl">üí∞</span>
                            <span className="text-yellow-400 font-black text-lg game-font">{formatNumber(totalCoins)}</span>
                        </div>
                        <div className="flex flex-col items-center">
                            <span className="text-white/90 font-black text-xl tracking-[0.2em] drop-shadow-md game-font">STAGE {level}</span>
                        </div>
                        
                        <div className="flex flex-col items-end cursor-pointer active:scale-95 transition-transform" onClick={handleProfile}>
                             <div className="text-[10px] text-yellow-500 font-bold tracking-wider">PLAYER</div>
                             <div className="text-sm font-bold text-white flex items-center gap-1">
                                {activeUserName} <span className="text-[10px] opacity-50">{user ? 'üåê' : '‚úèÔ∏è'}</span>
                             </div>
                        </div>
                    </div>

                    {/* BATTLE AREA */}
                    <div className="flex flex-col justify-between h-full py-4 pb-0 pt-0 relative z-10">
                        {/* ENEMY */}
                        <div className="relative flex flex-col items-center mt-6"> 
                            <div className={`relative w-32 h-32 ${enemyAnim} anim-sway-enemy z-30`}>
                                 {enemy.isBoss && <div className="absolute top-8 -left-12 w-20 h-20 opacity-80 z-0"><SmartImage assetKey="enemy_goblin" /></div>}
                                 <SmartImage assetKey={enemy.isBoss ? 'enemy_boss' : 'enemy_goblin'} className="drop-shadow-2xl z-20 relative" />
                            </div>
                            <div className="relative w-64 h-8 css-hp-bar -mt-4 z-20">
                                 <div className="absolute inset-0 bg-red-900 border border-slate-700"></div>
                                 <div className="absolute top-0 left-0 h-full bg-gradient-to-r from-green-500 to-green-400 transition-all duration-300" style={{width: `${(enemy.hp/enemy.maxHp)*100}%`}}></div>
                                 <div className="absolute inset-0 flex items-center justify-between px-3 text-xs font-bold text-white game-font z-10">
                                    <span>{enemy.name} (ATK:{enemy.atk})</span><span>{formatNumber(enemy.hp)}</span>
                                 </div>
                            </div>
                            {punchEffect === 'enemy' && <div className="absolute top-20 z-50 text-6xl anim-punch">üëä</div>}
                        </div>

                        {/* BOARD */}
                        <div className="flex-1 flex items-center justify-center relative my-0">
                            {particles.map(p => (
                                <div key={p.id} className="absolute w-12 h-12 anim-particle z-50" style={{top: p.top, left: p.left}}><SmartImage assetKey={GEM_CONFIG[p.type].assetKey} /></div>
                            ))}
                            <div className="relative w-full max-w-[360px] aspect-[6/7] p-2">
                                <div className="absolute inset-0 css-board-frame z-0"></div>
                                <div className="grid grid-cols-6 grid-rows-7 gap-1 h-full w-full relative z-10 p-3">
                                    {board.map((row, r) => row.map((type, c) => (
                                        <div key={`${r}-${c}`} 
                                             onMouseDown={(e) => handleDragStart(e, r, c)}
                                             onTouchStart={(e) => handleDragStart(e, r, c)}
                                             className={`relative w-full h-full flex items-center justify-center transition-transform active:scale-90 ${crushingCells.includes(`${r},${c}`) ? 'anim-crumble' : ''} ${isFalling ? 'anim-fall' : ''} ${type && !crushingCells.includes(`${r},${c}`) ? 'anim-pulse' : ''}`}
                                             style={isFalling ? { animationDelay: `${c * 40}ms` } : {}}>
                                             {type && <SmartImage assetKey={GEM_CONFIG[type].assetKey} className="drop-shadow-md" />}
                                        </div>
                                    )))}
                                </div>
                            </div>
                        </div>

                        {/* HERO & ITEMS */}
                        <div className="relative z-20 w-full flex flex-col items-center pb-8">
                            <div className="relative w-64 h-8 css-hp-bar mb-[-10px] z-10">
                                    <div className="absolute inset-0 bg-red-900 border border-slate-700"></div>
                                    <div className="absolute top-0 left-0 h-full bg-gradient-to-r from-green-500 to-green-400 transition-all duration-300" style={{width: `${(hero.hp/hero.maxHp)*100}%`}}></div>
                                    <div className="absolute inset-0 flex items-center justify-between px-3 text-xs font-bold text-white game-font z-10">
                                    <span>HERO (ATK:{hero.atk})</span><span>{formatNumber(hero.hp)}</span>
                                    </div>
                            </div>
                            <div className="relative w-36 h-36">
                                <div className={`w-full h-full ${heroAnim} anim-sway-hero z-30 relative`}><SmartImage assetKey="hero" className="drop-shadow-2xl scale-110 origin-bottom" /></div>
                                <div className="absolute -right-12 top-0 flex flex-col gap-2 z-50 anim-float">
                                    <button onClick={() => useItem('potion')} className={`w-9 h-9 rounded-full border-2 flex items-center justify-center relative btn-game shadow-xl ${inventory.potion > 0 ? 'bg-slate-700 border-green-500 text-lg' : 'bg-slate-800 border-slate-600 opacity-50 grayscale'}`}>
                                        üß™ <span className="absolute -top-1 -right-1 bg-red-500 text-white text-[9px] font-bold w-4 h-4 rounded-full border border-slate-900 shadow-sm">{inventory.potion}</span>
                                    </button>
                                    <button onClick={() => useItem('bomb')} className={`w-9 h-9 rounded-full border-2 flex items-center justify-center relative btn-game shadow-xl ${inventory.bomb > 0 ? 'bg-slate-700 border-orange-500 text-lg' : 'bg-slate-800 border-slate-600 opacity-50 grayscale'}`}>
                                        üí£ <span className="absolute -top-1 -right-1 bg-red-500 text-white text-[9px] font-bold w-4 h-4 rounded-full border border-slate-900 shadow-sm">{inventory.bomb}</span>
                                    </button>
                                    <button onClick={() => useItem('shuffle')} className={`w-9 h-9 rounded-full border-2 flex items-center justify-center relative btn-game shadow-xl ${inventory.shuffle > 0 ? 'bg-slate-700 border-blue-500 text-lg' : 'bg-slate-800 border-slate-600 opacity-50 grayscale'}`}>
                                        üîÑ <span className="absolute -top-1 -right-1 bg-red-500 text-white text-[9px] font-bold w-4 h-4 rounded-full border border-slate-900 shadow-sm">{inventory.shuffle}</span>
                                    </button>
                                </div>
                                {punchEffect === 'hero' && <div className="absolute bottom-20 z-50 text-6xl anim-punch">üëä</div>}
                            </div>
                        </div>
                    </div>

                    {floatingText.map(ft => (
                        <div key={ft.id} className="absolute z-[60] text-4xl font-black pointer-events-none text-center whitespace-nowrap" 
                             style={{top: '40%', left: '50%', transform:'translateX(-50%)', color: ft.color, textShadow:'2px 2px 0 #000', animation: 'float-up-fade 2s ease-out forwards'}}>
                             {ft.txt}
                        </div>
                    ))}

                    {/* MENUS (START, REWARD, SHOP, GAMEOVER) */}
                    {gameState === 'START' && (
                        <div className="absolute inset-0 z-50 bg-black/90 flex flex-col items-center justify-center p-4">
                            <h1 className="text-6xl font-black text-yellow-500 
